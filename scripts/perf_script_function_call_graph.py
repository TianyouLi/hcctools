# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

from __future__ import print_function

import os
import sys
import argparse 
import ipaddress
import pprint
import debugpy as dbg
import cxxfilt

from typing import List
from enum import Enum

sys.path.append(os.environ['PERF_EXEC_PATH'] + \
  '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from perf_trace_context import *
from Core import *
from EventClass import *

events = dict()

parser = argparse.ArgumentParser()
parser.add_argument("-d", "--debug",
                    help="enable debug host during script processing",
                    action="store_true",
                    dest="debug")
parser.add_argument("-l", "--debug-ip",
                    help="debuger listen ip address",
                    action="store",
                    dest="debug_ip",
                    type=ipaddress.ip_address,
                    default="127.0.0.1")
parser.add_argument("-p", "--debug-port",
                    help="debuger listen port",
                    action="store",
                    dest="debug_port",
                    type=int,
                    default="5678")
parser.add_argument("-s", "--symbol",
                    help="symbol to parse and analysis",
                    action="store",
                    dest="symbol",
                    type=str,
                    default="native_queued_spin_lock_slowpath")
parser.add_argument("-e", "--event-type",
                    help="event type to analysis",
                    action="store",
                    dest="event_type",
                    type=str,
                    default="cycles:pp")              

parser.add_argument("-g", "--graph",
                    help="generate the graph for particular function, \
                      with the file name specified, default as graph.html",
                    action="store",
                    dest="graphfilename",
                    type=str,
                    default="graph.html")

args = parser.parse_args()

def trace_begin():
  if args.debug:
    dbg.listen((str(args.debug_ip),args.debug_port))
    dbg.wait_for_client()
    dbg.breakpoint()

def get_dict_as_string(a_dict, delimiter=' '):
  return delimiter.join(['%s=%s'%(k,str(v))for k,v in sorted(a_dict.items())])
  
def trace_unhandled(event_name, context, event_fields_dict, perf_sample_dict):
  print(get_dict_as_string(event_fields_dict))
  print('Sample: {'+get_dict_as_string(perf_sample_dict['sample'], ', ')+'}')
  
def create_event_with_more_info(param_dict):
  event_attr = param_dict["attr"]
  sample     = param_dict["sample"]
  raw_buf    = param_dict["raw_buf"]
  comm       = param_dict["comm"]
  name       = param_dict["ev_name"]
  callchain  = param_dict["callchain"]

  # Symbol and dso info are not always resolved
  if ("dso" in param_dict):
    dso = param_dict["dso"]
  else:
    dso = "Unknown_dso"

  if ("symbol" in param_dict):
    symbol = param_dict["symbol"]
  else:
    symbol = "Unknown_symbol"

  # Create the event object and insert it to the right table in database
  event = create_event(name, comm, dso, symbol, event_attr)
  event.sample = sample
  event.cycles = event.sample["period"]
  event.attr = event_attr
  event.raw_buf = raw_buf
  event.callchain = callchain
  return event


class CallGraphNode(object):
  def __init__(self, symbol: str, cycles: int, level: int):
    self.symbol: str = symbol
    self.cycles: int = cycles
    self.level: int = level
    self.callers: List[CallGraphNode] = []
    self.callees: List[CallGraphNode] = []

  def __str__(self):
    if len(self.callers) > 0:
      caller_str = "\n".join([str(caller) for caller in self.callers])
    else:
      caller_str = ""
    if len(self.callees) > 0:
      callee_str = "\n".join([str(callee) for callee in self.callees])
    else:
      callee_str = ""

    return callee_str + "  " * self.level + cxxfilt.demangle(self.symbol) + ":" + str(self.cycles) + "\n" + caller_str 

  def __repr__(self):
    return str(self) 

  def find_caller(self, symbol: str) -> 'CallGraphNode':
    for node in self.callers:
      if node.symbol == symbol:
        return node
    return None
  
  def add_caller(self, symbol: str, cycles: int) -> 'CallGraphNode':
    caller = self.find_caller(symbol)
    if caller is None:
      caller = CallGraphNode(symbol, cycles, self.level +1)
      self.callers.append(caller)
    else:
      caller.cycles += cycles
    
    return caller

  def find_callee(self, symbol: str) -> 'CallGraphNode':
    for node in self.callees:
      if node.symbol == symbol:
        return node
    return None
  
  def add_callee(self, symbol: str, cycles: int) -> 'CallGraphNode':
    callee = self.find_callee(symbol)
    if callee is None:
      callee = CallGraphNode(symbol, cycles, self.level +1)
      self.callees.append(callee)
    else:
      callee.cycles += cycles
    
    return callee

class CallGraph(object):
  def __init__(self, symbol: str):
    self.symbol: str = symbol
    self.root: CallGraphNode = None
  
  def __str__(self):
    return f"Symbol: {self.symbol}\n"+ str(self.root)

  def find_symbol_index_in_callchain(self, event) -> List[int]:
    result: List[int] = []
    for index, item in enumerate(event.callchain):
      if 'sym' in item and item['sym'] is not None:
        symbol = item['sym']['name']
      else:
        symbol = hex(item['ip'])

      if symbol == self.root.symbol:
        result.append(index)
    return result

  def add_caller_nodes(self, callerchain: List, cycles: int):
    node: CallGraphNode = self.root
    for item in callerchain:
        if 'sym' in item and item['sym'] is not None:
          symbol = item['sym']['name']
        else:
          symbol = hex(item['ip'])
        node = node.add_caller(symbol, cycles)
  def add_callee_nodes(self, calleechain: List, cycles: int):
    node: CallGraphNode = self.root
    for item in reversed(calleechain):
      if 'sym' in item and item['sym'] is not None:
        symbol = item['sym']['name']
      else:
        symbol = hex(item['ip'])
      node = node.add_callee(symbol, cycles)  

  def process_event(self, event):
    if self.root is None:
      self.root = CallGraphNode(event.symbol, event.cycles, 0)
    else:
      self.root.cycles += event.cycles
    symbol_indexes = self.find_symbol_index_in_callchain(event)
    if len(symbol_indexes) == 1:
      symbol_indexes.append(len(event.callchain) +1)

    prev_index = 0 
    cur_index = symbol_indexes[0]
    for i, cur_index in enumerate(symbol_indexes):
      if i < (len(symbol_indexes) -1):
        next_index = symbol_indexes[i+1]
      else:
        next_index = len(event.callchain) +1
      # add caller
      callerchain = event.callchain[cur_index+1:next_index-1]
      self.add_caller_nodes(callerchain, event.cycles)
      if prev_index == 0:
        # add callee
        calleechain = event.callchain[prev_index:cur_index]
        self.add_callee_nodes(calleechain, event.cycles)
      prev_index = cur_index +1
      

graph: CallGraph = None
def create_callgraph_for_function(event, symbol: str):
  global graph 
  if graph is None:
    graph = CallGraph(symbol)
  if event.symbol == symbol:
    graph.process_event(event)
  
def process_event(param_dict):
  global events
    
  event = create_event_with_more_info(param_dict)
  if event.symbol == args.symbol and event.name == args.event_type:
    graph = create_callgraph_for_function(event, args.symbol)
  if event.name not in events:
    events[event.name] = {"total":event.sample["period"], "el": [event]}
  else:
    events[event.name]["total"] += event.sample["period"]
    events[event.name]["el"].append(event)

class GraphFileHtmlSankeyRender(object):

  html_header = """
  <html>                                                                                     
    <body>                                                                                   
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>  

    <div id="sankey_multiple" style="width: 900px; height: 300px;"></div>                    

    <script type="text/javascript">
      google.charts.load("current", {packages:["sankey"]});
      google.charts.setOnLoadCallback(drawChart);
      function drawChart() {
        var data = new google.visualization.DataTable();
        data.addColumn('string', 'From');
        data.addColumn('string', 'To');
        data.addColumn('number', 'Weight');
        data.addRows([
  """

  html_footer = """
    ]);

      // Set chart options
      var options = {
        width: 2048,
        height: 1024,
        sankey: {
          node: {
            label: {
              fontSize: 12
            }
          }
        },
      };

      // Instantiate and draw our chart, passing in some options.
      var chart = new google.visualization.Sankey(document.getElementById('sankey_multiple'));
      chart.draw(data, options);
    }
  </script>
  </body>
  </html>
  """

  def __init__(self, htmlfilename: str):
    self.htmlfilename = htmlfilename  
    self.sources: List[str] = []

  def render(self, graph: CallGraph):
    graphfilename = self.htmlfilename
    graphfile = open(graphfilename, "w")
    self.file = graphfile

    self.graph_write_html_header()

    self.generate_callee_row(graph.root)
    self.generate_caller_row(graph.root)  

    self.graph_write_html_footer()
    self.file.close()

  def graph_write_html_header(self):
    self.file.write(GraphFileHtmlSankeyRender.html_header)

  def graph_write_html_footer(self):
    self.file.write(GraphFileHtmlSankeyRender.html_footer)

  def get_available_dst_symbol(self, symbol: str):
    dst_symbol = symbol
    while dst_symbol in self.sources:
      dst_symbol = dst_symbol + "~"
    
    return dst_symbol

  def generate_one_row(self, source: CallGraphNode, target: CallGraphNode, weight: int):
    src_symbol = source.symbol
    dst_symbol = target.symbol

    if src_symbol not in self.sources:
      self.sources.append(src_symbol)

    dst_symbol = self.get_available_dst_symbol(dst_symbol)
    target.symbol = dst_symbol

    self.file.write(f"        ['{src_symbol}', '{dst_symbol}', {weight}],\n")

  def generate_callee_row(self, root: CallGraphNode):
    callees = root.callees

    for item in callees:
      if root.cycles / item.cycles > 1000:
        continue
      self.generate_one_row(item, root, item.cycles)
      self.generate_callee_row(item)
      self.sources.clear()

  def generate_caller_row(self, root: CallGraphNode):
    callers = root.callers

    for item in callers:
      if root.cycles / item.cycles > 1000:
        continue
      self.generate_one_row(root, item, item.cycles)
      self.generate_caller_row(item)
      self.sources.clear()




def trace_end():
  print(graph)

  graphfilename = args.graphfilename
  if not os.path.isabs(graphfilename):
      script_dir = os.path.dirname(os.path.abspath(__loader__.path))
      graphfilename = os.path.join(script_dir, graphfilename)

  render = GraphFileHtmlSankeyRender(graphfilename)
  render.render(graph)